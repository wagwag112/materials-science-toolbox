#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Author: Huy Hoang
Description: 
    Comparing RDF from AIMD (vasprun.xml) and MLIP (.traj). 
    If AIMD file is missing, the script proceeds with MLIP analysis only.
Usage:
    python rdf_validator.py <last_n_frames> <pair1> <pair2> ...
    Example: python rdf_validator.py 1000 Li-O O-O
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
from ase.io import read
from ase.geometry.analysis import Analysis
from scipy.signal import find_peaks
import sys
import os

class RDFValidator:
    def __init__(self, aimd_path, mlip_path, pairs, last_n_frames=500, r_max=6.0, n_bins=200):
        self.aimd_path = aimd_path
        self.mlip_path = mlip_path
        self.pairs = pairs
        self.last_n_frames = last_n_frames
        self.r_max = r_max
        self.n_bins = n_bins
        self.results_summary = []

    def _load_and_slice(self, path, file_format):
        """Loads trajectory if file exists, otherwise returns None."""
        if not os.path.exists(path):
            print(f"WARNING: File not found at {path}")
            return None
        
        try:
            traj = read(path, index=":", format=file_format)
            start_idx = max(0, len(traj) - self.last_n_frames)
            return traj[start_idx:]
        except Exception as e:
            print(f"ERROR: Could not read {path}: {e}")
            return None

    def _calculate_rdf(self, traj, pair):
        """Calculates averaged RDF and correct bin centers."""
        if traj is None:
            return None, None
            
        ana = Analysis(traj)
        rdf_list = ana.get_rdf(rmax=self.r_max, nbins=self.n_bins, elements=pair)
        rdf_avg = np.mean(rdf_list, axis=0)
        
        dr = self.r_max / self.n_bins
        r = (np.arange(self.n_bins) + 0.5) * dr
        return r, rdf_avg

    def _calculate_overlap_index(self, g_aimd, g_mlip):
        """Quantifies similarity (S). Returns None if data is missing."""
        if g_aimd is None or g_mlip is None:
            return None
        numerator = np.sum(np.minimum(g_aimd, g_mlip))
        denominator = np.sum(g_aimd)
        return numerator / denominator if denominator != 0 else 0

    def _get_main_peak(self, r, g_r):
        """Identifies primary peak position."""
        if g_r is None:
            return None, None
        peaks, _ = find_peaks(g_r, prominence=0.1*np.max(g_r), height=0.2*np.max(g_r))
        if len(peaks) == 0:
            return None, None
        highest_peak_idx = peaks[np.argmax(g_r[peaks])]
        return r[highest_peak_idx], g_r[highest_peak_idx]

    def run(self, output_prefix="RDF_Validation"):
        print(f"--> Initializing Analysis (Last {self.last_n_frames} frames)...")
        traj_aimd = self._load_and_slice(self.aimd_path, "vasp-xml")
        traj_mlip = self._load_and_slice(self.mlip_path, "traj")

        if traj_mlip is None:
            print("FATAL ERROR: MLIP trajectory is required but not found.")
            return None

        n_pairs = len(self.pairs)
        fig, axes = plt.subplots(1, n_pairs, figsize=(6*n_pairs, 5), squeeze=False)

        for i, pair in enumerate(self.pairs):
            pair_label = f"{pair[0]}-{pair[1]}"
            print(f"--> Processing pair: {pair_label}")

            # Calculate RDFs
            r_aimd, g_aimd = self._calculate_rdf(traj_aimd, pair)
            r_mlip, g_mlip = self._calculate_rdf(traj_mlip, pair)

            # Get Peaks
            r_p_aimd, g_p_aimd = self._get_main_peak(r_aimd, g_aimd)
            r_p_mlip, g_p_mlip = self._get_main_peak(r_mlip, g_mlip)
            
            # Comparison Metrics
            overlap_s = self._calculate_overlap_index(g_aimd, g_mlip)
            delta_r = (r_p_mlip - r_p_aimd) if (r_p_aimd and r_p_mlip) else np.nan

            # Log results
            self.results_summary.append({
                "Pair": pair_label,
                "AIMD_Peak_r": r_p_aimd,
                "MLIP_Peak_r": r_p_mlip,
                "Delta_r": delta_r,
                "Overlap_Index": overlap_s
            })

            # Plotting
            ax = axes[0, i]
            if g_aimd is not None:
                ax.plot(r_aimd, g_aimd, 'k-', lw=2, label='AIMD (DFT)', alpha=0.7)
            
            ax.plot(r_mlip, g_mlip, 'r-', lw=2, label='MLIP', alpha=0.8)

            # Annotation logic
            if g_aimd is not None:
                info_text = f"Δr: {delta_r:.3f} Å\nS: {overlap_s:.3f}"
            else:
                info_text = "AIMD Data: N/A"
            
            ax.text(0.55, 0.85, info_text, transform=ax.transAxes, fontsize=10,
                    verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

            ax.set_title(f"Pair: {pair_label}", fontsize=12, fontweight='bold')
            ax.set_xlabel("Distance r (Å)")
            ax.set_ylabel("g(r)")
            ax.legend(loc='upper right', fontsize=9)
            ax.grid(True, alpha=0.2)

        plt.tight_layout()
        plt.savefig(f"{output_prefix}.png", dpi=300)
        
        # Save CSV summary
        df = pd.DataFrame(self.results_summary)
        df.to_csv(f"{output_prefix}_Summary.csv", index=False)
        print(f"--> Results exported to {output_prefix}.png and CSV.")
        return df

if __name__ == "__main__":
    # --- HARDCODED PATHS (Will be checked by _load_and_slice) ---
    AIMD_PATH = "vasprun.xml" 
    MLIP_PATH = "md_production.traj"

    if len(sys.argv) < 3:
        sys.exit("Usage: python script.py <last_n_frames> <pair1> <pair2> ...")

    try:
        n_frames = int(sys.argv[1])
        input_pairs = [tuple(p.split("-")) for p in sys.argv[2:]]

        validator = RDFValidator(AIMD_PATH, MLIP_PATH, input_pairs, 
                                 last_n_frames=n_frames, r_max=4.0, n_bins=150)
        summary_df = validator.run()
        
        if summary_df is not None:
            print("\n--- Quick Summary ---")
            print(summary_df.to_string(index=False))

    except Exception as e:
        print(f"Execution failed: {e}")
